import pefile
import yara
import struct
import pdb
import time
import sys
from Crypto.Cipher import ARC4
import subprocess

"""
rule Emotet
{
    meta:
        author = "Nguyen Nguyen"
        description = "Emotet Payload"
        cape_type = "Emotet Payload"
    strings:
	$decrypt = {8b 0b 8d 5b 04 33 4d f4 0f b6 c1 66 89 06 8b c1 c1 e8 08 8d 76 08 0f b6 c0 66 89 46 fa c1 e9 10 0f b6 c1 c1 e9 08 47 66 89 46 fc 0f b6 c1}
    condition:
        uint16(0) == 0x5A4D and $decrypt
}
rule EmotetConfiguration
{
strings:
	$mz = "MZ"
	$c2init = {81 F9 ?? ?? ?? ?? 74 25 81 F9 ?? ?? ?? ?? 0f ?? ?? ?? ?? ?? E8 ?? ?? ?? ?? 85 c0 0f 84 ?? ?? ?? ?? E8 ?? ?? ?? ?? B9 ?? ?? ?? ?? EB 83 8D ?? ?? ?? B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B F0 8D ?? ?? ?? 89 ?? ?? ?? E8 ?? ?? ?? ?? 8B CE E8 ?? ?? ?? ?? B9 ?? ?? ?? ?? E9 ?? ?? ?? ?? B9}
condition:
	$mz at 0 and $c2init
}
"""
rule_source = '''
rule opcodes
{
strings:
	$mz = "MZ"
	$c2init = {81 F9 ?? ?? ?? ?? 74 25 81 F9 ?? ?? ?? ?? 0f ?? ?? ?? ?? ?? E8 ?? ?? ?? ?? 85 c0 0f 84 ?? ?? ?? ?? E8 ?? ?? ?? ?? B9 ?? ?? ?? ?? EB 83 8D ?? ?? ?? B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B F0 8D ?? ?? ?? 89 ?? ?? ?? E8 ?? ?? ?? ?? 8B CE E8 ?? ?? ?? ?? B9 ?? ?? ?? ?? E9 ?? ?? ?? ?? B9}
condition:
	$mz at 0 and $c2init
}
'''
rule_source2 = '''
rule opcodes
{
strings:
	$mz = "MZ"
	$c2 = {56 8B F1 6A 4C 59 E8 ?? ?? ?? ?? A3 ?? ?? ?? ?? 85 C0 74 3D B9 ?? ?? ?? ?? 33 D2 89 48 44}
condition:
	$mz at 0 and $c2
}
'''

def pe_data(pe, va, size):
    image_base = pe.OPTIONAL_HEADER.ImageBase
    rva = va - image_base
    key = struct.unpack('i', pe.get_data(rva, 4))[0]
    enc_size = struct.unpack('i', pe.get_data(rva+4, 4))[0]
    size = key ^ enc_size
    data = pe.get_data(rva+8, size*4)
    return data, key

def get_ips(pe, va):
    image_base = pe.OPTIONAL_HEADER.ImageBase
    rva = va - image_base
    key = struct.unpack('i', pe.get_data(rva, 4))[0]
    enc_size = struct.unpack('i', pe.get_data(rva+4, 4))[0]
    size = key ^ enc_size
    ips = []
    while True:
        data = pe.get_data(rva, 4)
	
        if struct.unpack('i', data)[0]==0:
            break
        rva = rva+8
        ip = "{}.{}.{}.{}".format(ord(data[3]), ord(data[2]), ord(data[1]), ord(data[0]))
	ips.append(ip)
    return ips

def decrypt(enckey, raw_data):
    i = 0
    s = ""
    while i < len(raw_data):
	data = struct.unpack('i', raw_data[i:i+4])[0]
        tmp = enckey ^ data
        s = s + chr(tmp&0xff) + chr((tmp>>8)&0xff) + chr((tmp>>16)&0xff) + chr((tmp>>24)&0xff)
        i = i + 4
    return s

def yara_scan(raw_data, rule, rule_name):
    yara_data = []
    yara_rules = yara.compile(source=rule)
    matches = yara_rules.match(data=raw_data)
    for match in matches:
        if match.rule == 'opcodes':
            for item in match.strings:
                if item[1] == rule_name:
                    data = raw_data[item[0]:item[0]+0x100]
                    yara_data.append(data)
    return yara_data

def config(raw_data):
    pe = pefile.PE(data=raw_data, fast_load=False)

    data = yara_scan(raw_data, rule_source, '$c2init')
    if len(data) >0:
        key_va = struct.unpack('i', data[0][50:54])[0]
        key_hex, key = pe_data(pe, key_va, 16)
	data = decrypt(key, key_hex)
	if len(data)>0:
	    open(sys.argv[1]+".der", "wb").write(data)
	    command = ["openssl", "rsa", "-in", sys.argv[1]+".der", "-RSAPublicKey_in",  "-inform", "DER", "-pubout", "-out", sys.argv[1]+".pem"]
	    subprocess.Popen(command)
            time.sleep(2)
	    print("Public Key:")
	    print(open(sys.argv[1]+ ".pem","r").read())

    data = yara_scan(raw_data, rule_source2, '$c2')
    if len(data) >0:
        key_va = struct.unpack('i', data[0][21:25])[0]
	ips = get_ips(pe, key_va)
	print("IPs:")
	for ip in ips:
		print("%s" % (ip))
	open(sys.argv[1]+".ioc", "wb").write("\n".join(ips))
config(open(sys.argv[1], "rb").read())
